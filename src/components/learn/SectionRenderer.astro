---
import { marked } from 'marked';
import { Callout } from '../docs';
import DataTable from './DataTable.astro';
import PropertyList from './PropertyList.astro';
import CrystalDemo from './CrystalDemo.astro';
import ComparisonBlock from './ComparisonBlock.astro';
import CrystalSystemCard from './CrystalSystemCard.astro';
import { detectCrystalSystem, type CrystalSystem } from './icons';
import { addMineralLinks } from '../../lib/mineral-linker';

interface Item {
  name: string;
  value?: string;
  description?: string;
  examples?: string[];
}

interface Table {
  caption?: string;
  headers: string[];
  rows: string[][];
}

interface CalloutData {
  type: 'info' | 'warning' | 'tip' | 'error';
  title?: string;
  text: string;
}

interface Crystal {
  cdl: string;
  caption?: string;
  interactive?: boolean;
}

interface Comparison {
  items: Array<{ title: string; points: string[]; variant?: 'default' | 'success' | 'warning' | 'danger' }>;
}

interface Subsection {
  title: string;
  content?: string;
  items?: Item[];
  table?: Table;
  system?: CrystalSystem;
  cdl?: string;
}

interface Section {
  title: string;
  id?: string;
  content?: string;
  callout?: CalloutData;
  items?: Item[];
  table?: Table;
  crystal?: Crystal;
  comparison?: Comparison;
  subsections?: Subsection[];
}

interface Props {
  section: Section;
}

const { section } = Astro.props;
const sectionId = section.id || section.title.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

// Configure marked for safe rendering
marked.setOptions({
  breaks: true,
  gfm: true,
});

// Helper to render markdown with mineral auto-linking
const renderMarkdown = async (text: string) => {
  const html = await marked.parse(text);
  return addMineralLinks(html);
};

// Pre-render all markdown content with mineral links
const sectionContent = section.content ? await renderMarkdown(section.content) : null;
const calloutContent = section.callout?.text ? await renderMarkdown(section.callout.text) : null;

// Pre-render subsection content
const subsectionContent = section.subsections
  ? await Promise.all(
      section.subsections.map(async (sub) => ({
        ...sub,
        renderedContent: sub.content ? await renderMarkdown(sub.content) : null,
      }))
    )
  : null;
---

<section id={sectionId} class="mb-16">
  <h2 class="text-2xl font-bold text-slate-900 mb-6 pb-3 border-b border-slate-200">{section.title}</h2>

  {section.callout && calloutContent && (
    <Callout variant={section.callout.type} title={section.callout.title}>
      <Fragment set:html={calloutContent} />
    </Callout>
  )}

  {sectionContent && (
    <div class="prose prose-slate max-w-none mb-6" set:html={sectionContent} />
  )}

  {section.crystal && (
    <CrystalDemo
      cdl={section.crystal.cdl}
      caption={section.crystal.caption}
      interactive={section.crystal.interactive ?? true}
    />
  )}

  {section.items && (
    <PropertyList items={section.items} />
  )}

  {section.table && (
    <DataTable
      headers={section.table.headers}
      rows={section.table.rows}
      caption={section.table.caption}
    />
  )}

  {section.comparison && (
    <ComparisonBlock items={section.comparison.items} />
  )}

  {subsectionContent && subsectionContent.map(sub => {
    // Check if this subsection is a crystal system
    const detectedSystem = sub.system || detectCrystalSystem(sub.title);

    if (detectedSystem) {
      // Render as a crystal system card
      return (
        <CrystalSystemCard
          system={detectedSystem}
          title={sub.title}
          content={sub.content}
          items={sub.items}
          cdl={sub.cdl}
        />
      );
    } else {
      // Render as a regular subsection with improved styling
      return (
        <div class="mt-8 rounded-xl border border-slate-200 bg-white overflow-hidden">
          <div class="bg-slate-50 px-4 py-3 border-b border-slate-200">
            <h3 class="text-lg font-semibold text-slate-800">{sub.title}</h3>
          </div>
          <div class="p-4">
            {sub.renderedContent && (
              <div class="prose prose-slate max-w-none mb-4" set:html={sub.renderedContent} />
            )}
            {sub.items && <PropertyList items={sub.items} />}
            {sub.table && <DataTable headers={sub.table.headers} rows={sub.table.rows} caption={sub.table.caption} />}
          </div>
        </div>
      );
    }
  })}
</section>
